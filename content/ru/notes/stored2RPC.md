---
title: "Хранимки и RPC"
description: "Взгляд на RPC со стороны хранимок"
date: 2022-12-14
draft: false
enableToc: true
---
# Взгляд на RPC со стороны хранимок

## Предисловие

Когда идею совмещения HTML и PHP в одном файле начали считать неправильной, я был рад, считая, что такое совмещение
1. требует переключать контекст между разными синтаксическими сущностями
2. размазывает требования к квалификации разработчика - уже недостаточно разбираться в одной из двух технологий

Когда идея микросервисов начала принимать форму "каждому сервису - свою БД", я был удивлен и опечален тем, что выводы из истории HTML+PHP, очевидные для меня, никто не разделял.
В контексте микросервисов я рассматриваю только СУБД, которые поддерживают хранимый код, поэтому выводы мои были такие:

1. SQL и ЯП - разные контексты и первый шаг распила монолита - это отдать их разным командам 
2. если предоставить ЯП некий АПИ по работе с БД, то этот ЯП может быть любым. Плюс заменить БД тоже будет проще
3. если набрать команду, которая отвечает только за данные и операции с ними, предоставляя АПИ, то.. по мне так это здорово, но это не в тренде и опенсорсных решений для такой команды нет (см. ниже про миграции)

Далее - о том, как я вижу RPC с точки зрения моего опыта в хранимках

## Описание АПИ

АПИ - это набор сервисов, состоящих из методов. Для каждого метода задается сигнатура - аргументы, результат и описание их структур

Для АПИ результат метода желательно иметь простым (скаляр, структура или массив структур), но в самой БД связи могут быть сложнее (не все поля из N таблиц, а некое, адекватное задаче, представление)

Из этого я сделал вывод, что первичной должна быть схема данных, по которой для каждого метода формируются структуры, которые уже могут быть использованы в описании АПИ.

На этом этапе получается такой план

1. описать предметную область
2. спроектировать структуры данных
3. описать методы и их сигнатуры
4. загрузить это в БД и проверить корректность
5. по содержимому БД сгенерить описание АПИ (не парсить исходники, а взять метаданные из БД)
6. вот тут распараллелим - БД:реализация хранимок и тестов, Клиенты:реализация

> На текущий момент я под термином "описание АПИ" понимаю protobuf

## Генерация кода

Итак, у нас есть .proto и по нему мы можем сгенерить

1. Интерфейсы для сервиса (например - на golang)
2. Клиента (на поддерживаемых генераторами ЯП)
3. Спецификацию OpenAPI (со всеми вытекающими)

Но ведь сервис просто будет вызывать хранимки, чего не хватает для его генерации?

* ACL (права доступа) 
* Cache (мы работаем с БД, тут это - важно)

Есть варианты

1. протащить эти два пункта через спецификацию и сразу генерить сервис, который исполняет SQL
2. описать их в БД и для генерации сервиса сделать к ней нужные запросы

На мой взгляд, если в protobuf найдется решение - надо выбрать его, иначе придется сочинить собственный стандарт и там выбрать

## Хранимки

В чем я вижу их плюс

1. вся логика работы с БД инкапсулируется внутри нее и клиентам доступен только некий АПИ
2. взаимодействие приложения с БД сводится к запросам вида `select a,b from func(x,y)`
3. даже парсить ничего не надо - уже все есть в метаданных БД, и сигнатуры и комментарии/документация

### Миграции

Насколько мне известно, основной вариант миграций в настоящее время - это оформить в один или несколько файлов все изменения БД текущей миграции. В частности, если надо поменять код хранимки или представления - он дублируется с исправлениями (привет, git)

Однако, конструкция `CREATE OR REPLACE {FUNCTION|VIEW}` позволяет обновить код в работающей системе. А если обернуть ее в транзакцию и добавить тесты - то обновление сработает только при их успехе.

Если мы уберем из рассмотрения системы миграции, которые этот факт не учитывают, что останется?
Мой ответ - написать свою (к слову, мой самопис в продакшене уже 10 лет)

## FAQ

### Почему protobuf а не OpenAPI

REST - это для HTTP, круг моих задач шире (там нет PUT/DELETE/etc) и мне нужен RPC. А для HTTP я бы предпочел RO запросы делать в GET, остальные в POST. И в обоих случаях имя метода хотелось бы видеть в access.log

### Где взять спецов по БД и хранимкам

Такие люди есть, но рынок их спрятал за "золотой забор". Все же хотели "SQL+PHP/Ruby/JS/Java/GO/Rust". В итоге спецы по "вечному" начали размываться и тратить время на "приходящее". И рынок за это заплатит, я считаю.

### Что-то кроме PostgreSQL?

Сомневаюсь. Я в прошлом веке к нему пришел, с тех пор стараюсь мониторить альтернативы, но ничего лучше не видел. Хотя, на современный Линтер надо бы глянуть