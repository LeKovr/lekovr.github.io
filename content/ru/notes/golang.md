---
title: "GoLang Solutions"
description: "Решения типовых задач"
date: 2020-02-17
draft: false
enableToc: true
---

Ниже приведены мои варианты решения типовых задач, которые у меня возникали при разработке на golang.

## `func main()`

Пока я не нашел удобный способ тестировать `main()`, мой вариант - сократить эту функцию до одной строки и убрать ее из тестов.

Если репозиторий содержит бинарник с именем `APP`, его функция `main()` размещается в отдельном файле `cmd/APP/main.go` со следующим содержанием:

{{< source "static/src/golang/main.go" >}}

## log

1. [structured logging](https://www.client9.com/structured-logging-in-golang/) - чтобы парсить без геморроя, для прода это json stream. т.е. если в пакете логгирования есть строка формата - это сразу убираем
2. поддержка терминала. Да, в проде хорош json, но при отладке хотелось бы цветной читабельный логгинг в терминал

Пока не было log/slog, я смотрел на тему так:

* для случаев, отличных от примитивных, необходима возможность парсить логи приложения. Тут мой выбор - [structured logging](https://www.client9.com/structured-logging-in-golang/) и вариант его реализации - [zap](https://github.com/uber-go/zap)
* вместе с этим, зашивать конкретную имплементацию журналирования мне представляется не оптимальным, поэтому в пакетах использую [logr](https://github.com/go-logr/logr)
* в тестах, если надо собрать логи и потом проанализировать, я использую [genericr](https://github.com/wojas/genericr)

Теперь ситуация изменилась

* не осталось причин не использовать глобально пакет log/slog. Все его настройки можно сделать на старте, а работа с контекстом стала даже удобнее
* Для логгирования контекста вместо `log.FromContext` использую `slog.ErrorContext`
* если понадобится зависимость уровня логгирования от пакета - это решится в slog.Handler

## log usage

Ссылка на log не передается конструктору и не является глобальной переменной. Она передается в конкретном вызове или через контекст.

Почему: В строку журнала может понадобиться добавить переменную со значением из текущего запроса (например - traceId, или еще что-то уровнем выше текущего пакета)

## config

Для конфигурации приложения наиболее характерный пример для меня - использование библиотеки, у которой есть свой конфиг, при обновлении которого я бы не хотел ничего менять в своем приложении. Я использую [go-flags](https://github.com/jessevdk/go-flags) и выглядит это так:

```go
type Config struct {
        Addr        string `long:"http_addr" default:"localhost:8080"  description:"Http listen address"`

        FS  lookupfs.Config `group:"Filesystem Options" namespace:"fs" env-namespace:"FS"`
        API procapi.Config  `group:"API Options" namespace:"api" env-namespace:"API"`
}
```

<!-- 
## errors

## tests

-->

## pg

Однажды, в [mqbridge](https://github.com/LeKovr/mqbridge), мне понадобилось работать с каналом (`db.Listen(channel).Channel()`), для этого я выбрал [go-pg](https://github.com/go-pg/pg/v9). В остальных случаях использую [pgx](https://github.com/jackc/pgx/v4)

## embedding

Выбор пакета для меня определяется ответом на вопрос - "Нужна ли UnionFS" (т.е. возможность локальным файлом заменить какой-то файл из дистрибутива)

* если нужна - [go-imbed](https://github.com/growler/go-imbed)
* если нет - [parcello](https://github.com/phogolabs/parcello)

Начиная с go 1.16, первичный вариант решения - `embed`

## deploy

Тут все очевидно. Как автор [dcape](https://github.com/dopos/dcape), деплой всех своих приложений я делаю так. Другие варианты - это уже подарки тестовых задач. Добавлю, что, на мой взгляд, навык заворачивания приложения в docker я считаю полезным для программиста, а опыт управления kubernetes - нет. По двум причинам (k8s не единственный и не последний. Разве это не экспертиза уровня webpack?)

<!--
## DB app (pgmig)

### apisite
### pggrpc


## Dockerfile
```
# cache deps
go mod download

# краткий пример сборки проекта, чтобы не искать его в Makefile, не использует make
go build
```
-->

## errors

В точке возникновения ошибки коду доступен
* контекст
* аргументы вызова текущей функции
* стек

Эти данные важны разработчику, но не пользователю (которому хватит номера ошибки и текста).
Из этого я делаю вывод, что в момент отлова ошибки надо в лог положить все детали и переменные контекста, а наверх отдать какой-то примитив или ID. Но уж точно не надо весь контекст момента ошибки тащить наверх в полях ошибки.

## cache

Если кешируем БД, для меня первейшая фича - если значения в кэше нет, обратиться к БД и поставить в очередь все такие же запросы. Я это нашел - [groupcache](https://pkg.go.dev/github.com/golang/groupcache#GetterFunc)
Смысл очевиден - не грузить БД одинаковыми запросами

Если нет работы с БД - все проще. Есть много вариантов и в какой-то момент я вышел на [решение от patrickmn](https://github.com/patrickmn/go-cache).
Следующий вариант [сделал arp242](https://github.com/arp242/zcache), добавив к предыдущему дженерики. И это мой текущий выбор

## generated code naming

На мой взгляд, есть плюсы в добавлении префикса "z" к имени файла, если он генерируется. Как минимум, это облегчает ревью, оставляя все такие правки на конец.
Вот [пример](https://cs.opensource.google/go/go/+/refs/tags/go1.21.4:src/syscall/zerrors_aix_ppc64.go) из исходников Go.

Мое личное предпочтение по этой теме - выносить все генерируемое в папку /gen, как сделано [тут](https://github.com/LeKovr/showonce/tree/master/zgen)ю
