# Взгляд на RPC со стороны хранимок

## Предисловие

Когда идею совмещения HTML и PHP в одном файле начали считать неправильной, для меня, в числе аргументов "за это" было то, что такое совмещение
1. требует переключать контекст между разными синтаксическими сущностями
2. размазывает требования к квалификации разработчика - уже недостаточно разбираться в одной из двух технологий

Когда идея микросервисов начала принимать форму "каждому сервису - свою БД", я был удивлен и опечален тем, что выводы из истории HTML+PHP, очевидные для меня, никто не разделял.
В контексте микросервисов я рассматриваю только СУБД, которые поддерживают хранимый код, поэтому выводы мои были такие:

1. SQL и ЯП - это разные контексты, первый шаг масштабирования - отдать их разным командам 
2. если предоставить ЯП некий АПИ по работе с БД, то этот ЯП может быть любым. Плюс заменить БД тоже будет проще
3. если представить команду, которая отвечает только за данные и операции с ними, предоставляя АПИ, то.. на текущий момент, общепринятого открытого решения не существует

Далее - о том, как я вижу RPC с точки зрения моего опыта в хранимках

## Описание АПИ

АПИ - это набор сервисов, состоящих из методов. Для каждого метода задается сигнатура - аргументы, результат и описание их структуры

Для АПИ результат метода желательно иметь простым (скаляр, структура или массив структур), но в самой БД связи могут быть сложнее (не все поля из 2х таблиц, а некое адекватное задаче представление)

Из этого я делаю вывод, что первичной должна быть схема данных, по которой для каждого метода формируются структуры, которые уже могут быть использованы в описании АПИ.

На этом этапе получается такой план

1. описать предметную область
2. спроектировать структуры данных
3. описать методы и из сигнатуры
4. загрузить это в БД и проверить корректность (не парсить исходники, а взять метаданные из БД)
5. по содержимому БД сгенерить описание АПИ
6. вот тут распараллелим - БД:реализация хранимок и тестов, Клиенты:реализация

На текущий момент я под термином "описание АПИ" понимаю protobuf

## Генерация кода

Итак, у нас есть .proto и по нему мы можем сгенерить

1. Интерфейсы для сервиса (например - на golang)
2. Клиента (на поддерживаемых генераторами ЯП)
3. Спецификацию OpenAPI (со всеми вытекающими)

Но ведь сервис просто будет вызывать хранимки, чего нехватает для его генерации?

* ACL (права доступа) 
* Cache (мы работаем с БД, тут это - важно)

Есть варианты

1. протащить эти два пункта через спецификацию и сразу генерить сервис, который исполняет SQL
2. описать их в БД и для генерации сервиса сделать к ней нужные запросы

На мой взгляд, если в protobuf найдется решение - надо выбрать его, иначе придется сочинить собственный стандарт и там выбрать

## Хранимки

В чем я вижу их плюс

1. вся логика работы с БД инкапсулируется внутри нее и клиентам доступен только некий АПИ
2. взаимодействие приложения с БД сводится к запросам вида `select a,b from func(x,y)`
3. даже парсить ничего не надо - уже все есть в метаданных БД, и сигнатуры и комментарии

### Миграции

Насколько мне известно, основной вариант миграций в настоящее время - это оформить в один или несколько файлов все изменения БД текущей миграции. В частности, если надо поменять код хранимки или представления - он дублируется с исправлениями (привет гиту)

Однако, конструкция `CREATE OR REPLACE {FUNCTION|VIEW}` позволяет обновить код в работающей системе. А если обернуть ее в транзакцию и добавить тесты - то обновление сработает только при их успехе.

Если мы уберем из рассмотрения системы миграции, которые этот факт не учитывают, что останется?
Мой ответ - написать свою. К слову, мой самопис в продакшене уже 10 лет.

## FAQ

### Почему protobuf а не OpenAPI

REST - то для HTTP, круг моих задач шире и мне нужен RPC. А для HTTP я бы предпочел RO запросы делать в GET, остальные в POST. 

### Где взять спецов по БД и хранимкам

Такие люди есть, но рынок их спрятал за "золотой забор". Все же хотели "SQL+PHP/Ruby/JS/Java/GO/Rust". В итоге спецы по "вечному" начали размываться и тратить время на "приходящее". И рынок за это заплатит, я считаю.

### Что-то кроме PostgreSQL?

Сомневаюсь. Я в прошлом веке к нему пришел, с тех пор стараюсь мониторить альтернативы, но ничего лучше не видел. Хотя, на современный Линтер надо бы глянуть